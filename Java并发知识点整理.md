## Java并发编程知识点梳理

## 并发编程的目的：
- 提高性能，提高CPU的利用率

## 常见的并发问题：
- 安全性问题：

- 活跃性问题：

- 性能问题：

## 导致并发问题的常见原因：
- 原子性：
    > 多个线程来回切换，在多个CPU上跑，导致不同的CPU看到的，不是最新的。
    > 
    > *编译器和处理器在做指令重排序时，会遵循数据依赖性，他们不会改变数据依赖关系的两个执行顺序。（单处理器才有）*

- 有序性：
    > - 因为会有编译器重排序、指令级并行重排序、内存系统重排序
    > - 会让程序在执行指令时，重新排序，没数据依赖的情况，会让这些指令优化后执行。

- 可见性：
    > - 一个线程，修改了一个数据，另外一个线程，能否立刻看到，我们叫可见性
    > - 由于重排序等问题，导致了程序不是按照先后顺序执行，所以有时候会出现有序性问题    
    > - 指令重排序后，先后执行，导致不同的线程，看到的结果不同。
    > - 多核处理器在多个核心上执行，没有及时把数据由各个核心的缓存刷新到主存。
    > - 多个线程，A线程修改了内存变量，B线程没有及时看到。
## 并发问题的解决方案：
  
  > 找到了并发问题的源头，解决这些源头，就可以解决并发问题了。    
    
## Java语言对并发问题的解决方案：

- 原子性

- 有序性
  > 指令重排序到值得，所以可以禁止指令重排序，来达到有序性不被打乱。
  > JMM通过插入内存屏障（memory barrier）的手段，来实现。

- 可见性：
  > JMM通过happens-before来搞定这个事：





------------------------------------------------------------------------
死锁：一组相互竞争资源的线程，因相互等待，导致”永久“阻塞的现象。

Coffman说：只有满足以下四点，才会发生死锁：
	1：互斥：共享资源X和Y只能被一个线程占用；
	2：占有切等待：线程T1已经取得共享资源X，在等待共享资源Y的时候，不释放共享资源X；（参考，转账时，A线程拿了A账户，B线程拿了B账户）；
	3：不可抢占：其他线程不能强行抢占线程T1占有的资源；
	4：循环等待：线程T1等待线程T2占有的资源，线程T2等待线程T1占有的资源，就是循环等待；
		
	1. Mutual Exclusion: 
	2. Hold and wait or  resource holding
	3. No preemption
	4. Circular wait
破坏上述4种情况，就可以避免死锁：
	1：互斥：没法破坏，我们用锁，就是为了互斥；
	2：占用且等待：一次性申请所有条件即可。
		用一个管家类，来管理，一次性申请多个资源，
	3：不可抢占：占用部分资源的线程，在进一步申请其他资源时，申请不到，可以主动释放它占有的资源。
	4：循环等待：可以按照顺序，来申请资源，防止2号资源被别的线程申请到，1号资源被自己申请到。


用细粒度锁，来锁定多个资源时，首先就要想到：不能死锁！；



Java内存模型，是用过那几个方面来解决这个问题的

Java内存模型：

	重排序：
		有三种：
            1：编译器优化的重排序
                语言的编译器进行的排序
            2：指令级并行的重排序
                现代的处理器采用了指令层级并行技术，将将多条指令重叠执行。
            3：内存系统的重排序
        源码 --> 编译器重排序 --> 指令级并行重排序 --> 内存系统重排序
        上述三种重排序，都有可能导致内存可见性问题。
            JMM通过让CPU特定的内存屏障指令，让CPU来对某些指令不重排。