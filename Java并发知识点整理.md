## Java并发编程知识点梳理

## 并发编程的目的：
- 提高性能，提高CPU的利用率

## 常见的并发问题：
- 安全性问题：

- 活跃性问题：

- 性能问题：

## 导致并发问题的常见原因：
- 原子性：
    > - 线程切换带来的问题
    > - 举个例子，马上懂：

        ```java
            // 我要转账给我老婆10块钱
            // field
            private int my_balance = 10;
            private int target_balance;
            // method
            if (my_balance >= 10) {
                // 我老婆账号+10
                target_balance = target_balance + 10;
                // 我自己账号-10块
                my_balance = my_balance - 10;
            }
            /*
                有2个线程同时在跑，
                A线程是我转给我老婆10块钱
                B线程是我转给小卖部5块钱
                因为多个多线程是并发运行的。
                A线程执行了my_balance >= 10这个条件，通过后，让出了CPU执行权，
                B线程也执行了my_balance >= 10这个条件，这个时候，my_balance的余额还是初始值10。所以也通过了。
                这2个线程判断这个条件都通过了，后面都会执行这个余额转出并-10的操作。这就有问题了。
                因为这个if代码块，不是原子操作，所以会出现问题。
            */

        ```

- 有序性：
    > - 因为会有编译器重排序、指令级并行重排序、内存系统重排序带来的问题
    > - 会让程序在执行指令时，重新排序，没数据依赖的情况，会让这些指令优化后执行。
    > - 由于重排序等问题，导致了程序不是按照先后顺序执行，所以有时候会出现有序性问题    
    > - 指令重排序后，先后执行，导致不同的线程，看到的结果不同。
    > *编译器和处理器在做指令重排序时，会遵循数据依赖性，他们不会改变数据依赖关系的两个执行顺序。（单处理器才有）*

- 可见性：
    > - 缓存带来的问题
    > - 一个线程，修改了一个数据，另外一个线程，因为缓存没有立刻见到，叫可见性
    > - 多核处理器在多个核心上执行，没有及时把数据由各个核心的缓存刷新到主存

## 并发问题的通用解决方案：

- 解决原子性：不做多线程，单核跑

- 解决有序性：按需禁止编译优化（编译优化包括，编译器层面、CPU层面的）

- 解决可见性：按需禁用缓存（缓存包括：语言及线程层面的、CPU层面的L1\L2\L3等）

## 并发问题在Java中的解决方案：

- 原子性

- 有序性&可见性
  > 解决有序性及可见性的手段是：按需禁用缓存及编译优化java通过：volatile、Synchronized、final三个关键字，以及六项happens-before规则，来达到这个目的
  
  - valotile
    > volatile在C里就有，原始意义就是禁用CPU缓存
  - Synchronized

  - final
  - happens-before
    1. 程序的顺序性规则
    2. volatile变量规则
    3. 传递性
    4. 管城中的锁规则
    5. 线程start()规则
    6. 线程join()规则

------------------------------------------------------------------------
#### 死锁：一组相互竞争资源的线程，因相互等待，导致”永久“阻塞的现象

- Coffman说：只有满足以下四点，才会发生死锁：
  1. 互斥(Mutual Exclusion: )：共享资源X和Y只能被一个线程占用；
  2. 占有且等待(Hold and wait or  resource holding)：线程T1已经取得共享资源X，在等待共享资源Y的时候，不释放共享资源X；（参考，转账时，A线程拿了A账户，B线程拿了B账户）；
  3. 不可抢占(No preemption)：其他线程不能强行抢占线程T1占有的资源；
  4. 循环等待(Circular wait)：线程T1等待线程T2占有的资源，线程T2等待线程T1占有的资源，就是循环等待；

- 破解方案：破坏上述4种情况的其中一种，就可以避免死锁：
  1. 互斥：没法破坏，我们用锁，就是为了互斥；
  2. 占用且等待：一次性申请所有条件即可。用一个管家类，来管理，一次性申请多个资源，
  3. 不可抢占：占用部分资源的线程，在进一步申请其他资源时，申请不到，可以主动释放它占有的资源。
  4. 循环等待：可以按照顺序，来申请资源，防止2号资源被别的线程申请到，1号资源被自己申请到。

- 关于锁的一些其他信息：
  - 用细粒度锁，来锁定多个资源时，首先就要想到：不能死锁！


---
### Java线程的状态：
- NEW 
- RUNNING
- BLOCKED
- WAITING
- TIME_WAITING
- TERNIMATED

> 上面的状态，BLOCKED比较特殊，只有当线程拿不到对象锁的时候，线程才会变成BLOCKED这个状态

> WAITING和TIME_WAITING这2个状态，都是线程自己掉了wait之类的方法，才会变成这样子的，TIME_WAITING嘛，就是调用wait等的时候，加了个超时时间。时间超了，会xxx
