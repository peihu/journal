## Java并发编程知识点梳理

## 并发编程的目的：
- 提高性能，提高CPU的利用率

## 常见的并发问题：
- 安全性问题：

- 活跃性问题：

- 性能问题：

## 导致并发问题的常见原因：
- 原子性：
    > 多个线程来回切换，在多个CPU上跑，导致不同的CPU看到的，不是最新的。
    > 
    > *编译器和处理器在做指令重排序时，会遵循数据依赖性，他们不会改变数据依赖关系的两个执行顺序。（单处理器才有）*

- 有序性：
    > - 因为会有编译器重排序、指令级并行重排序、内存系统重排序
    > - 会让程序在执行指令时，重新排序，没数据依赖的情况，会让这些指令优化后执行。

- 可见性：
    > - 一个线程，修改了一个数据，另外一个线程，能否立刻看到，我们叫可见性
    > - 由于重排序等问题，导致了程序不是按照先后顺序执行，所以有时候会出现有序性问题    
    > - 指令重排序后，先后执行，导致不同的线程，看到的结果不同。
    > - 多核处理器在多个核心上执行，没有及时把数据由各个核心的缓存刷新到主存。
    > - 多个线程，A线程修改了内存变量，B线程没有及时看到。
## 并发问题的解决方案：
  
  > 找到了并发问题的源头，解决这些源头，就可以解决并发问题了。    
    
## Java语言对并发问题的解决方案：

- 原子性

- 有序性
  > 指令重排序到值得，所以可以禁止指令重排序，来达到有序性不被打乱。
  > JMM通过插入内存屏障（memory barrier）的手段，来实现。

- 可见性：
  > JMM通过happens-before来搞定这个事：

------------------------------------------------------------------------
#### 死锁：一组相互竞争资源的线程，因相互等待，导致”永久“阻塞的现象

- Coffman说：只有满足以下四点，才会发生死锁：
  1. 互斥(Mutual Exclusion: )：共享资源X和Y只能被一个线程占用；
  2. 占有且等待(Hold and wait or  resource holding)：线程T1已经取得共享资源X，在等待共享资源Y的时候，不释放共享资源X；（参考，转账时，A线程拿了A账户，B线程拿了B账户）；
  3. 不可抢占(No preemption)：其他线程不能强行抢占线程T1占有的资源；
  4. 循环等待(Circular wait)：线程T1等待线程T2占有的资源，线程T2等待线程T1占有的资源，就是循环等待；

- 破解方案：破坏上述4种情况的其中一种，就可以避免死锁：
  1. 互斥：没法破坏，我们用锁，就是为了互斥；
  2. 占用且等待：一次性申请所有条件即可。用一个管家类，来管理，一次性申请多个资源，
  3. 不可抢占：占用部分资源的线程，在进一步申请其他资源时，申请不到，可以主动释放它占有的资源。
  4. 循环等待：可以按照顺序，来申请资源，防止2号资源被别的线程申请到，1号资源被自己申请到。

- 关于锁的一些其他信息：
  - 用细粒度锁，来锁定多个资源时，首先就要想到：不能死锁！


---
### Java线程的状态：
- NEW 
- RUNNING
- BLOCKED
- WAITING
- TIME_WAITING
- TERNIMATED

> 上面的状态，BLOCKED比较特殊，只有当线程拿不到对象锁的时候，线程才会变成BLOCKED这个状态

> WAITING和TIME_WAITING这2个状态，都是线程自己掉了wait之类的方法，才会变成这样子的，TIME_WAITING嘛，就是调用wait等的时候，加了个超时时间。时间超了，会xxx
